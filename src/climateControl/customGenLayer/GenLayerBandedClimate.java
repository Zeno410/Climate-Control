
package climateControl.customGenLayer;

import climateControl.api.Climate;
import climateControl.api.ClimateControlSettings;
import climateControl.api.IslandClimateMaker;
import climateControl.genLayerPack.GenLayerPack;
import com.Zeno410Utils.IntRandomizer;
import net.minecraft.init.Biomes;
import net.minecraft.world.biome.Biome;
import net.minecraft.world.gen.layer.GenLayer;
import net.minecraft.world.gen.layer.IntCache;

/**
 *
 * @author Zeno410
 */
public class GenLayerBandedClimate extends GenLayerPack implements IslandClimateMaker {

    private final int bandWidth;
    private final int [] bandClimate = new int[6];
    private final int offset;
    private final boolean frozenIcecaps;
    private final boolean separateLandmasses;

    public GenLayerBandedClimate(long par1, GenLayer par3GenLayer,ClimateControlSettings settings, int multiplier)
    {
        super(par1);
        this.parent = par3GenLayer;
        this.offset = settings.bandedClimateOffset.value()*multiplier -multiplier/2;
        this.bandWidth = settings.bandedClimateWidth.value()*multiplier;
        bandClimate[0] = 2;// warm
        bandClimate[1] = 1;// hot
        bandClimate[2] = 2;// warm
        bandClimate[3] = 3;// cool
        bandClimate[4] = 4;// snowy
        bandClimate[5] = 3;// cool
        this.frozenIcecaps = settings.frozenIcecaps.value();
        this.separateLandmasses = settings.separateLandmasses.value();
    }

    /**
     * Returns a list of integer values generated by this layer. These may be interpreted as temperatures, rainfall
     * amounts, or biomeList[] indices based on the particular GenLayer subclass.
     */
    public int[] getInts(int par1, int par2, int par3, int par4){
        int[] aint = this.parent.getInts(par1, par2, par3, par4);
        int[] aint1 = new int[par3 * par4];

        for (int i1 = 0; i1 < par4; ++i1)
        {
            for (int j1 = 0; j1 < par3; ++j1)
            {
                int latitude = par2+i1+offset;
                int band = 0;
                if (latitude >=0) {
                    // positive
                    band = latitude/bandWidth;
                    band = band%6;
                } else {
                    //negative; have to adjust for rounding towards zero
                    band = (latitude-bandWidth+1)/bandWidth;
                    band = band%6;
                    if (band <-5) {
                        throw new RuntimeException(""+latitude + " " + band);
                    }
                    // adjust the lower cool to be band 0
                    if (band <0) band +=6;
                }
                if (aint[j1 + i1 * par3] == 0) {
                    if (this.frozenIcecaps&&bandClimate[band]==4) {
                        aint1[j1 + i1 *par3] = Biome.getIdForBiome(Biomes.FROZEN_OCEAN);
                    } else {
                        aint1[j1 + i1 *par3] = 0;
                    }
                } else {
                    aint1[j1 + i1 *par3] = bandClimate[band];
                    if (separateLandmasses) {
                        aint1[j1 + i1 *par3] += aint[j1 + i1 * par3]*4;
                    }
                }

            }
        }

        return aint1;
    }

    public int climate(int x, int latitude, IntRandomizer randomizer) {
            int band = 0;
            latitude += offset;
            if (latitude >=0) {
                // positive
                band = (latitude)/bandWidth;
                band = band%6;
            } else {
                //negative; have to adjust for rounding towards zero
                band = (latitude-bandWidth+1)/bandWidth;
                band = band%6;
                if (band <-5) {
                    throw new RuntimeException(""+latitude + " " + band);
                }
                // adjust the negatives
                if (band <0) band +=6;
            }
            return bandClimate[band];
    }
}